\chapter{提案手法}
\section{用語定義}
本稿で多用されている用語は定義が曖昧であり、またゲーム開発者以外には馴染み浅い言葉である。

そのため、本稿で用いられている用語について以下に解説する。

\subsection{レベル}
「レベル」とは、広義ではゲーム中における一定のある小単位を示す。

ゲームの種類によっては「ステージ」、「マップ」、「面」などと呼ばれることも多い。

一般的に扱われるレベルという単語は、難易度やプレイヤー習熟度を包括した意味合いで用いられることが多いが、
本稿での「レベル」はプレイヤー熟練度の意味は成さない。


\subsection{レベルデザイン}
前項で解説した「レベル」を具体的に設計、パラメータの調整を行うことをレベルデザインと呼び、それを行う開発者をレベルデザイナーと呼ぶ。


また、広義では、「レベル」の設計のみならず、ゲームルールの設計そのものを行うことを「レベルデザイン」と呼ぶことがあるが、
本項では「ゲームデザイン」の意味で用いられるレベルデザインとは区別する。

\section{システムの目的}
今回、設計を目指すシステムは、クラウドを用いてプレイヤーのプレイログを集計し、プレイログの収集や可視化、またそれを用いた
ゲームレベルの不具合検出や自動改善を目的とする。

\section{仮説}
\subsection{プレイバリューを向上させるレベルデザイン}
ゲーム開発の現場においては、一般的に以下の点を満たすレベルを良質なレベルと見なしている。

\subsubsection{レベルの序列}
レベルの難易度の序列が、ゲームのプレイ進行度に応じて徐々に上昇していくこと。

また、新たなゲーム中の要素が順序立てて出現し、プレイヤーへの手解きを兼ねていること。

\subsubsection{クリア可能であるか}
全てのレベルがクリア可能であること。いわゆる「ハマり」が起こらないこと

\subsubsection{極端に高難易度なレベルがないこと}
極端にクリア率の低い難易度を持つレベルが入り込まないこと。

\section{理想的なシステムの動作}
下記のようなユースケースを満たすシステムが理想的なシステムと考えられる。

\begin{enumerate}
  \item レベルデザイナーがあるゲームのレベルを複数登録する
  \item レベルデータをランダムにプレイヤーに配信する
  \item プレイヤーによるプレイログ、操作履歴、プレイ後のアンケートなどがレベル毎にシステムに蓄積される
  \item 蓄積されたプレイログの統計処理を行い、デザイナーが統計やログの閲覧ができる
  \item 蓄積されたデータを元に、問題のあると思われるレベルを検出する
  \item レベル内の問題のあるカ所をシステムが指摘する
  \item 指摘された問題点を修正したレベルを生成し、システムに再登録する
\end{enumerate}

本稿では、上記のユースケースのうち、4のログの集計までを目標とし、システムを構築した。

\section{実装したシステム}

今回、実験にあたり、以下のようなシステムを設計し、LeDA(Level Design Assistant)と命名した。

\begin{figure}[htbp]
  \begin{center}
    \includegraphics[bb=0 0 956 566, width=24cm]{images/logo.png}
  \end{center}
  \caption{LeDA}
  \label{fig:one}
\end{figure}

LeDAは以下のような機能を有する

\begin{itemize}
  \item デザイナーによるレベルの登録
  \item プレイヤーへのレベルデータの配信
  \item プレイヤーアンケート収集
  \item プレイヤー毎の各種統計処理
  \item レベル毎の各種統計処理
  \item 1ゲームのプレイログの再生
  \item 複数のプレイログの同時再生
\end{itemize}

\section{システムの設計}
システムはWebアプリケーションとしてサーバー上に構築されており、以下のモデルが実装されている。

この項での解説においては、多くのゲームシステムを持ったゲームに対応するため、抽象的なモデル設計について議論するが、
実際の実験に利用した具体的なゲームルール上に適応できるモデルは第4章において詳解する。

\subsection{Level}
Levelはゲームにおけるレベル1つ1つを表すモデルである。

通常はシステム管理者がシステムに登録する。

Levelは通常、マップデータなどがテキスト形式で保存されているが、データ構造はゲームによって異なる。

\subsection{Player}
Playerは、あるプレイヤーを一意に特定するためのモデルである。

今回は、PlayerはIPアドレスのみを保持し、IPアドレスが同一かどうかで、同一のPlayerだと仮定する


同様のPlayerによるプレイログを辿ることにより、プレイヤーのプレイ回数による習熟度の変化を観測することができる。

\subsection{Metric}
Metricはプレイヤーのプレイログを表すモデルで、１回のゲームプレイにつき一つが生成される。

Metricはそれぞれ以下の情報を保持している

\begin{itemize}
  \item プレイされたLevel
  \item プレイしたPlayer
  \item Operationsのリスト
  \item 一つ前のMetricへの参照
  \item Metricの最終状態
  \item 回答されたQuestionnaire
\end{itemize}

1つ前のMetricは、このMetricが生成される前に行われたゲームプレイを表すMetricへの参照が張られている。
これをたどることで、このゲームプレイが初回プレイなのか、別のlevelをプレイ後にプレイされた物なのか、前回も同様のLevelをプレイしていたにもかかわらず、クリアできずにリプレイした
ゲームプレイなのか、といった情報を判別できる。

Metricの最終状態には、このMetricがどのような状態で終了したかが保存される。初期状態はプレイ中(Playing)となっているが、
クリアした場合はClear、ゲームオーバーになってしまった場合はGameOverなどが記録される。
今回は簡単のため、Clear, GameOver、Playingの3つの状態のみ仮定しているが、プレイの状態をゲームの内容に応じてさらに細分化することもできる。

\subsection{Operation}
プレイヤーの行動１つ１つを示したモデル。例えばクリック位置や、ゲーム中で選択したコマンドなど、プレイヤーの行動が記録されている。

内容や生成頻度はゲームルールによって異なる。
例えば、アクションゲームの場合、毎フレーム生成されることもあるが、ターンベースのゲームの場合、各ターン終了時に生成されることもある。

行動内容の他にタイムスタンプがミリ秒単位で記録され、システム管理者はMetricに関連づけられたOperationのリストを辿ることで、プレイヤーの入力を完全に再現できる。

\subsection{Questionnaire}
プレイヤーのアンケート結果を示したモデル。

システム管理者は任意のアンケートを発行し、各プレイの終了後、プレイヤーに回答させることができる。
回答は対応するMetricに関連づけられる。

アンケートの内容はゲームシステム、管理者の運用によって異なる。

\section{システムの動作の流れ}
本項では、前項で説明したデータベース(以下、DB)上のモデルをどのように扱うか、プレイヤーの操作の順を追って、細かな処理を解説する。

ここでは、プレイヤーがプレイを開始し、ゲームオーバー、クリア、または途中での離脱など、なんらかの理由でプレイを終了するまでの単位を「ゲーム」と定義する。

図3.2は処理の流れを示したフローチャートである。以下、この図に沿って解説を行う。

\begin{figure}[htbp]
  \begin{center}
    \includegraphics[bb=0 0 1024 768, width=15cm]{images/flow.png}
  \end{center}
  \caption{システムのフローチャート}
  \label{fig:one}
\end{figure}

\subsection{1. アクセス後の処理}
プレイヤーがWebブラウザにアクセスすると、プレイヤーのリクエストをシステムが受け、アクセス元のIPアドレスを参照する。

IPアドレスをDBから検索し、もし存在していなければ、そのアクセスが新規プレイヤーだと仮定し、新たなPlayerを生成し、DBに格納する。
もし、存在していれば、そのPlayerをDBから取得する。

その後、システムに登録されているLavelの中からランダムに1つを選択、LevelとPlayerを関連づけた新しいMetricを生成する。

このMetric1つ1つが1ゲーム分のログを表すデータである。

システムは生成されたMetricの主キーとLevelのデータをクライアントに返却する

\subsection{2. ゲームの開始}
サーバーからLevelのデータを受け取ると、ブラウザ上ではそのデータを元にLevelが再現され、即座にゲームが起動する。

プレイヤーはサーバーとの通信を意識することなくゲームをプレイすることができる。


\subsection{3. プレイヤー操作の記録}
プレイヤーのゲーム中での入力操作と現在のMetricの主キーが、操作を行う度にサーバーへ送信される。

サーバーはその情報を受け、受け取った入力操作を元にOperationを生成し、Metricに追加する。

この操作は、ゲーム終了まで何度も行われる。

\subsection{4. ゲーム状態の変化}
ゲーム中でプレイヤーがクリアやゲームオーバー状態に達したとき、その変化を現在のMetricの主キーと共にサーバーに送信する。

システムはその情報を受け、対応するMetricの状態を変更する。これによって、そのプレイの最終状態がどのような状態で終わったかをシステム管理者が容易に把握することができる。


\subsection{5. ゲームの終了}
プレイヤーがクリアする、または未クリアだがギブアップを選択したとき、プレイ後に何らかのアンケートが表示され、プレイヤーの声を収集することもできる。アンケートの結果はサーバーに送信され、
Questionnaireが生成され、現在のMetricと関連づけられる。


未クリアかつ、リプレイを選択した場合、アンケートは表示されずに、1のステップへ戻り、ランダムに選択されたLevelではなく、現在と同様のLevelが再び配信される。
また、現在のMetricが次に生成されるMetricに関連づけられる。

\subsection{6. 次のゲームの開始}
5までのステップで、一連のプレイログの記録が終了し、ここまでのデータを一つのMetricとして扱う。

プレイヤーが他のレベルに挑戦したい場合、再び1の手順とほぼ同様の処理が行われ、新たなLevelの配信と、Metricの生成が行われる。

このとき、必ず現在遊んだLevelと異なったLevelが配信されてくる。また、次に新しく生成されるMetricの前のMetricとして、現在のMetricが関連づけられる。


\section{実装}
実装は主にサーバーサイドとクライアントサイドに分かれて行われている。

\subsection{サーバーサイド}
サーバーサイドの実装は、Python製のWeb Application FrameworkであるDjangoにより実装されている。このFrameworkはOSSであり、簡単に利用できる。

このFrameworkにより実装されたシステムを、Apache上でPythonを動作させるモジュール、mod\_wsgiを用いてサーバー上で動作させている。

また、アプリケーション上で生成されたモデルを格納するリレーショナル・データベースは、取り扱いの容易さの観点からsqlite3を採用している。

\subsection{クライアントサイド}
クライアントサイドでは、ゲームロジックがJavaScriptで記述され、HTML5のCanvasタグにより描画されている。

またJavaScriptのソースコードは、メタ言語であるCoffeeScriptで記述されている。

その他、サーバーとクライアントの通信に、JavaScript製ライブラリであるjQueryを利用している。
サーバーとのデータ通信は、サーバーのアプリケーション上にあるモデルをJSONというデータ記述言語としてダンプし、その文字列をやりとりすることにより行っている。
